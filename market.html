<style>
    .scrollable-column {
      max-height: 80vh;
      overflow-y: auto;
    }
  
    .trade-status-animate {
      font-weight: bold;
      color: black;
      animation: blink 2s infinite alternate;
    }
  
    @keyframes blink {
      from { opacity: 1; }
      to { opacity: 0.1; }
    }
  
    .loading {
      position: relative;
    }
    
    .loading::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(255, 255, 255, 0.7);
      z-index: 10;
    }
  </style>
  
  <div class="container" id="marketPage">
    <div class="row">
      <div class="col-md-4 scrollable-column">
        <div class="card">
          <div class="card-body">
            <h5 class="card-title">Market</h5>
            <div class="row">
              <div class="col-auto">
                <label for="marketSelect" class="form-label align-bottom">Market:</label>
              </div>
              <div class="col-auto align-top">
                <select class="form-select" id="marketSelect">
                  <option value="">Loading markets...</option>
                </select>
              </div>
            </div>
            <div class="row mt-2">
              <input type="text" value="Loading...." class="form-control trade-status-animate text-center" id="activeMarket" disabled>
            </div>
            <div class="row mt-2">
              <div class="col-md-6">
                <label for="askInput" class="form-label">Ask:</label>
                <input type="number" value="0" class="form-control text-center" id="askInput" disabled>
              </div>
              <div class="col-md-6">
                <label for="quoteInput" class="form-label">Quote:</label>
                <input type="number" value="0" class="form-control text-center" id="quoteInput" disabled>
              </div>
            </div>
            <div class="row mt-2">
              <div class="col-md-6">
                <label for="bidInput" class="form-label">Bid:</label>
                <input type="number" value="0" class="form-control text-center" id="bidInput" disabled>
              </div>
              <div class="col-md-6">
                <label for="pipSizeInput" class="form-label">Pip Size:</label>
                <input type="number" value="0" class="form-control text-center" id="pipSizeInput" disabled>
              </div>
            </div>
          </div>
        </div>
  
        <div class="card mt-3">
          <div class="card-body">
            <h5 class="card-title">Trade</h5>
            <div class="mb-3">
              <label for="tradeTypeSelect" class="form-label">Trade type:</label>
              <select class="form-select" id="tradeTypeSelect">
                <option value="">Loading trade types...</option>
              </select>
            </div>
            <div class="mb-3">
              <label for="timeLeftInput" class="form-label">Time Left:</label>
              <input type="text" class="form-control text-center" id="timeLeftInput" disabled>
            </div>
            <div class="mb-3">
              <label for="targetProfit" class="form-label">Target Profit:</label>
              <div class="input-group">
                <button class="btn btn-outline-secondary" type="button" id="decreaseProfit" aria-label="Decrease profit">-</button>
                <input type="number" class="form-control text-center" id="targetProfit" value="10" min="1" max="200">
                <button class="btn btn-outline-secondary" type="button" id="increaseProfit" aria-label="Increase profit">+</button>
              </div>
            </div>
            <div class="mb-3">
              <label for="entryAdviceInput" class="form-label">Entry Advice:</label>
              <input type="text" class="form-control" id="entryAdviceInput" disabled>
            </div>
            <div class="mb-3">
              <label for="entryProbabilityInput" class="form-label">Entry Probability:</label>
              <input type="number" class="form-control" id="entryProbabilityInput" disabled>
            </div>
            <button class="btn btn-primary" id="startTraderBtn">Start Trader</button>
            <button class="btn btn-danger" id="stopTraderBtn" disabled>Stop Trader</button>
          </div>
        </div>
      </div>
  
      <div class="col-md-8">
        <div class="card">
          <div class="card-body">
            <h5 class="card-title">Graph</h5>
            <div id="tradingGraph" style="height: 400px;">
              <p class="card-text text-center py-5">Graph will be displayed here</p>
            </div>
          </div>
        </div>
  
        <div class="card mt-3">
          <div class="card-body">
            <h5 class="card-title">Session Trading Log</h5>
            <div id="tradingLog" style="height: 200px; overflow-y: auto;">
              <p class="card-text text-center py-5">Trading log will appear here</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <script type="module">
    import { stateManager } from './src/stateManager.js';
    import WebSocketManager from './src/websocketManager.js';
    import { CONFIG } from './src/constants.js'; // Assuming constants are moved

    class TradingApp {
      constructor() {
        this.wsManager = new WebSocketManager(`${CONFIG.WS_URL}?app_id=${CONFIG.APP_ID}`);
        this.timerInterval = null; // Added timer interval reference
        this.init();
      }

      async init() {
        this.registerCleanup();
        this.initDOMReferences();
        this.initEventListeners();
        await this.connectWebSocket();
        this.startTimer(); // Assuming timer is still needed
      }

      registerCleanup() {
        window.currentPageCleanup = [
          () => this.cleanup()
        ];
      }

      initDOMReferences() {
        this.elements = {
          marketSelect: document.getElementById("marketSelect"),
          askInput: document.getElementById("askInput"),
          quoteInput: document.getElementById("quoteInput"),
          bidInput: document.getElementById("bidInput"),
          pipSizeInput: document.getElementById("pipSizeInput"),
          activeMarket: document.getElementById("activeMarket"),
          tradeTypeSelect: document.getElementById("tradeTypeSelect"),
          timeLeftInput: document.getElementById("timeLeftInput"),
          targetProfit: document.getElementById("targetProfit"),
          entryAdviceInput: document.getElementById("entryAdviceInput"),
          entryProbabilityInput: document.getElementById("entryProbabilityInput"),
          decreaseProfitBtn: document.getElementById("decreaseProfit"),
          increaseProfitBtn: document.getElementById("increaseProfit"),
          startTraderBtn: document.getElementById("startTraderBtn"),
          stopTraderBtn: document.getElementById("stopTraderBtn"),
          tradingLog: document.getElementById("tradingLog"),
          tradingGraph: document.getElementById("tradingGraph")
          // ... other element references
        };
      }

      initEventListeners() {
        // Market Selection
        this.elements.marketSelect.addEventListener('change', (e) => {
          stateManager.updateState(state => ({
            trading: { ...state.trading, currentMarket: e.target.value }
          }));
          this.updateMarketInfo(e.target.value); // Keep direct update for now
        });

        // Target Profit Adjustment
        this.elements.decreaseProfitBtn.addEventListener('click', () => {
          const currentValue = parseInt(this.elements.targetProfit.value);
          const minValue = parseInt(this.elements.targetProfit.min);
          if (currentValue > minValue) {
            this.elements.targetProfit.value = currentValue - 1;
            stateManager.updateState(state => ({
              trading: { ...state.trading, settings: { ...state.trading.settings, targetProfit: currentValue - 1 } }
            }));
          }
        });

        this.elements.increaseProfitBtn.addEventListener('click', () => {
          const currentValue = parseInt(this.elements.targetProfit.value);
          const maxValue = parseInt(this.elements.targetProfit.max);
          if (currentValue < maxValue) {
            this.elements.targetProfit.value = currentValue + 1;
            stateManager.updateState(state => ({
              trading: { ...state.trading, settings: { ...state.trading.settings, targetProfit: currentValue + 1 } }
            }));
          }
        });

        // Target Profit Input Validation & State Update
        this.elements.targetProfit.addEventListener('change', (e) => {
          let value = parseInt(e.target.value);
          const min = parseInt(e.target.min);
          const max = parseInt(e.target.max);

          if (isNaN(value)) value = min;
          else if (value < min) value = min;
          else if (value > max) value = max;

          e.target.value = value; // Update input field
          stateManager.updateState(state => ({
            trading: { ...state.trading, settings: { ...state.trading.settings, targetProfit: value } }
          }));
        });

        // Trade Type Selection
        this.elements.tradeTypeSelect.addEventListener('change', (e) => {
          stateManager.updateState(state => ({
            trading: { ...state.trading, settings: { ...state.trading.settings, tradeType: e.target.value } }
          }));
        });

        // Start/Stop Trader Buttons
        this.elements.startTraderBtn.addEventListener('click', () => {
          stateManager.updateState(state => ({
            trading: { ...state.trading, active: true }
          }));
          this.logMessage("Auto trading started"); // Keep logging for now
        });

        this.elements.stopTraderBtn.addEventListener('click', () => {
          stateManager.updateState(state => ({
            trading: { ...state.trading, active: false }
          }));
          this.logMessage("Auto trading stopped"); // Keep logging for now
        });
      }

      async connectWebSocket() {
        try {
          await this.wsManager.connect();
          this.logMessage("WebSocket connected.");
          this.fetchMarkets();
          this.setupWebSocketListeners(); // Setup listeners after connection
        } catch (error) {
          console.error('WebSocket connection failed:', error);
          this.logMessage("WebSocket connection failed. Check console.");
        }
      }

      setupWebSocketListeners() {
        // Handle market data (active symbols)
        this.wsManager.subscribe('active_symbols', (data) => {
          if (data.active_symbols) {
            stateManager.updateState({ markets: data.active_symbols });
            this.populateMarkets(data.active_symbols); // Update UI directly
            this.populateTradeTypes(); // Update UI directly
          } else if (data.error) {
            this.logMessage(`Error fetching markets: ${data.error.message}`);
          }
        });

        // Handle tick data (will be managed per market selection)
        // The subscription logic is moved to updateMarketInfo
      }


      fetchMarkets() {
        // Request active symbols
        this.wsManager.send(JSON.stringify({
          "active_symbols": "brief",
          "product_type": "basic"
        }));
      }

      populateMarkets(markets) {
        this.elements.marketSelect.innerHTML = ""; // Clear existing options
        markets.forEach(symbol => {
          const option = document.createElement("option");
          option.value = symbol.symbol;
          option.text = symbol.display_name;
          this.elements.marketSelect.appendChild(option);
        });

        // Select the first market or the one from state if available
        const currentMarket = stateManager.getState().trading.currentMarket;
        if (currentMarket && markets.some(m => m.symbol === currentMarket)) {
          this.elements.marketSelect.value = currentMarket;
          this.updateMarketInfo(currentMarket);
        } else if (markets.length > 0) {
          this.elements.marketSelect.value = markets[0].symbol;
          this.updateMarketInfo(markets[0].symbol);
        }
      }

      populateTradeTypes() {
        // Assuming trade types are static for now
        this.elements.tradeTypeSelect.innerHTML = `
          <option value="rise_fall">Rise/Fall</option>
          <option value="even_odd" selected>Even/Odd</option>
          <option value="over_under">Over/Under</option>
        `;
        // Set selected based on state
        this.elements.tradeTypeSelect.value = stateManager.getState().trading.settings.tradeType;
      }

      updateMarketInfo(marketSymbol) {
        if (!marketSymbol) return;

        this.elements.activeMarket.value = "Loading...";

        // Unsubscribe from previous market's ticks
        const previousMarket = stateManager.getState().trading.currentMarket;
        if (previousMarket && previousMarket !== marketSymbol) {
           this.wsManager.unsubscribe(`ticks_${previousMarket}`); // Assuming channel name format
        }

        // Update state
         stateManager.updateState(state => ({
            trading: { ...state.trading, currentMarket: marketSymbol }
          }));


        // Subscribe to new market's ticks
        const tickChannel = `ticks_${marketSymbol}`; // Define a unique channel name
        this.wsManager.subscribe(tickChannel, (data) => {
          if (data.tick) {
            this.updateTickData(data.tick);
          } else if (data.error) {
            this.elements.activeMarket.value = data.error.message;
            this.logMessage(`Market error: ${data.error.message}`);
          }
        });

         // Send the actual tick subscription message
         this.wsManager.send(JSON.stringify({ "ticks": marketSymbol, "subscribe": 1 })); // Ensure subscribe flag is sent
      }

       updateTickData(tick) {
          this.elements.askInput.value = tick.ask;
          this.elements.bidInput.value = tick.bid;
          this.elements.quoteInput.value = tick.quote;
          this.elements.pipSizeInput.value = tick.pip_size;
          this.elements.activeMarket.value = tick.symbol; // Update active market display
       }


      // Timer functionality (assuming it's still needed)
      startTimer() {
        this.clearTimer();
        let timeLeft = CONFIG.TIMER_DURATION; // Use local variable
        this.elements.timeLeftInput.value = timeLeft;

        this.timerInterval = setInterval(() => {
          timeLeft--;
          this.elements.timeLeftInput.value = timeLeft;

          if (timeLeft <= 0) {
            timeLeft = CONFIG.TIMER_DURATION; // Reset timer
            this.onTimerComplete();
          }
        }, 1000);
      }

      clearTimer() {
        if (this.timerInterval) {
          clearInterval(this.timerInterval);
          this.timerInterval = null;
        }
      }

      onTimerComplete() {
        if (stateManager.getState().trading.active) {
          this.evaluateTrade();
        }
      }

      evaluateTrade() {
        // TODO: Implement actual trade evaluation logic based on state
        const probability = Math.floor(Math.random() * 100); // Placeholder
        this.elements.entryProbabilityInput.value = probability;

        if (probability > 50) {
          this.elements.entryAdviceInput.value = "BUY";
          this.elements.entryAdviceInput.classList.add("text-success");
          this.elements.entryAdviceInput.classList.remove("text-danger");
        } else {
          this.elements.entryAdviceInput.value = "SELL";
          this.elements.entryAdviceInput.classList.add("text-danger");
          this.elements.entryAdviceInput.classList.remove("text-success");
        }
      }

      logMessage(message) {
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = document.createElement("div");
        logEntry.textContent = `[${timestamp}] ${message}`;
        // Ensure log area is cleared if it becomes too large (optional)
        if (this.elements.tradingLog.children.length > 100) {
            this.elements.tradingLog.removeChild(this.elements.tradingLog.lastChild);
        }
        this.elements.tradingLog.prepend(logEntry); // Add new log to the top
      }


      cleanup() {
        console.log("Cleaning up Market page resources...");
        this.wsManager.close();
        this.clearTimer();
        // Any other specific cleanup for this page
      }
    }

    // Initialize with state subscription
    document.addEventListener('DOMContentLoaded', () => {
      const tradingApp = new TradingApp();

      // Subscribe to state changes for UI updates
      stateManager.subscribe((state) => {
        // Update button states based on trading activity
        tradingApp.elements.startTraderBtn.disabled = state.trading.active;
        tradingApp.elements.stopTraderBtn.disabled = !state.trading.active;

        // Update target profit input if it differs from state
        if (parseInt(tradingApp.elements.targetProfit.value) !== state.trading.settings.targetProfit) {
            tradingApp.elements.targetProfit.value = state.trading.settings.targetProfit;
        }

        // Update trade type dropdown if it differs from state
         if (tradingApp.elements.tradeTypeSelect.value !== state.trading.settings.tradeType) {
            tradingApp.elements.tradeTypeSelect.value = state.trading.settings.tradeType;
         }

        // Update market dropdown if it differs from state
         if (state.trading.currentMarket && tradingApp.elements.marketSelect.value !== state.trading.currentMarket) {
             // Check if the market exists in the dropdown before setting
             const marketExists = Array.from(tradingApp.elements.marketSelect.options).some(opt => opt.value === state.trading.currentMarket);
             if (marketExists) {
                tradingApp.elements.marketSelect.value = state.trading.currentMarket;
             }
         }

        // Potentially update other UI elements based on state changes
        // e.g., update graph, display user info, etc.
      });
    });
  </script>